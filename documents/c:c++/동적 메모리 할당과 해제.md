# 동적 메모리 할당과 해제

## in this article
* 동적 메모리 할당과 해제를 이해해야 되는 이유
* 메모리 할당과 해제
* malloc & free

## 동적 메모리 할당과 해제를 이해해야 되는 이유
C/C++를 비롯해 자바 프로그래밍의 경우 필수적으로 동적 메모리 할당을 해야만 한다. 

할당된 메모리를 처리할 때는 차이가 발생한다. 

자바의 경우 할당 받은 메모리 해제를 가비지 컬렉터가 알아서 수행하지만, C/C++의 경우 개발자가 직접 메모리 해제를 해야 한다. 

직접 메모리 해제를 해야 하는 것이 무척 부담스러운 일인데, 해제도 꽤 많은 신경을 써야한다는 점에서 어려운 점이 있다. 

메모리 해제를 엉성하게 했다가는 어느 순간 프로그램이 죽어버리는 불상사가 생기기도 한다. 

이번 글의 목적은 C/C++의 동적 메모리 할당과 해제의 원리에 대해서 심층적으로 파악하고, 잘못된 메모리 해제로 인한 불상사를 겪지 않는 것이다.

## 메모리 할당과 해제
C/C++ 프로그래밍을 조금이라도 해봤다면 기본적으로 동적 메 모리 할당을 위하여 malloc, new, new [ ] 등을 사용해야만 하는 것을 알고 있다. 또한 해제를 위해서는 free, delete, delete [ ]를 사 용해야 한다는 것도 알고 있다. 중요한 철칙이 있는데, 할당과 해 제는 짝을 맞추어야 한다는 점이다. 즉, malloc으로 할당된 메모리 는 free로 해제하고, new는 delete로, new [ ]의 경우 반드시 delete [ ]로 해제해야 한다는 점이다.

이런 철칙을 잘 지키는 프로그래머는 훌륭한 자질을 가지고 있 다고 할 수 있다. 왜 철칙이겠는가? 반드시 지켜야만하기 때문에 철칙인 것이다. 다른 말로 하면 철칙을 지키지 않으면 그만한 대가 를 치르게 된다는 것을 의미한다.

그러나 필자 같은 삐딱한 프로그래머는 왜 그것이 철칙이어야 하는지 도통 이해하기가 어려웠다. ‘그냥 free나 delete로 통일하면 얼마나 좋아!’라며 늘 의문을 가졌다. 지금부터 필자가 품은 의문을 풀어보자!


## malloc & free
C++가 나오기 전 C에서는 메모리 할당과 해제를 위해 malloc과 free를 사용했다(메모리 할당 함수는 calloc 및 realloc과 같은 형제 함수들도 있으나, 일반적으로 대표적인 메모리 할당 함수는 malloc이다).




<리스트 1> malloc & free 원형

void * malloc(size_t size);
void free(void* memblock);




<리스트 1>에서 확인할 수 있듯이, malloc은 요청한 size만큼의 메모리를 할당해 할당된 메모리 블록의 주소를 반환한다. 할당받 은 메모리를 해제하기 위해서는 메모리 블록의 주소를 free에 인자 로 넘기기만 하면 된다. 여기서 주의할 점이 있는데, free에 넘기는 인자는 오직 malloc(calloc, realloc 포함)으로 이미 할당받은 메모 리 블록의 주소여야 한다는 것이다. 만일 유효하지 않은 주소를 free에 넘기게 될 경우 어떤 에러가 발생할지 알 수 없다(즉각적으 로 에러가 발생하지 않는 경우도 많다. 이런 경우 디버깅은 더욱 어려워질 수밖에 없다).

malloc과 free의 동작을 통해 추측할 수 있는 것이 있는데, 바로 C 내부적으로 malloc으로 할당받은 메모리 블록의 주소와 크기를 관리하고 있다는 점이다. 실제로 CRT(C Runtime Library)의 힙 매니저는 malloc으로 할당된 메모리 내역을 관리하며, free의 요청 에 대응한다.

<그림>

<그림 1>처럼 힙 관리자는 메모리 블록을 할당할 때마다 메모리 할당 내역을 저장하게 된다. 그림의 할당 내역 테이블에는 p1, p2, p3처럼 이름이 들어가 있지만, 실제로는 p1, p2, p3의 메모리 주소 가 들어가게 된다. free를 호출하게 될 경우 힙 관리자는 인자로 넘 어온 메모리 주소를 할당 내역에서 검색해 존재할 경우 할당된 크 기만큼 해당 메모리 블록을 해제하고, 할당 내역에서 삭제한다



## new & delete
